"use strict";(self.webpackChunkme=self.webpackChunkme||[]).push([[2817],{9475:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=o(4848),i=o(8453);const r={slug:"zero-downtime-deployment-with-docker-compose-nginx",title:"Zero-downtime Deployments with Docker Compose & Nginx",authors:["pxuanbach"],tags:["automation","deployment","docker","nginx","shell script"],date:"2024-03-24T10:00",image:"/img/01_zero-downtime-deployment-with-docker-compose-nginx/featured.png"},s=void 0,a={permalink:"/blog/zero-downtime-deployment-with-docker-compose-nginx",source:"@site/blog/01_zero-downtime-deployment-with-docker-compose-nginx/index.md",title:"Zero-downtime Deployments with Docker Compose & Nginx",description:"Hey, welcome to my blog!",date:"2024-03-24T10:00:00.000Z",tags:[{label:"automation",permalink:"/blog/tags/automation"},{label:"deployment",permalink:"/blog/tags/deployment"},{label:"docker",permalink:"/blog/tags/docker"},{label:"nginx",permalink:"/blog/tags/nginx"},{label:"shell script",permalink:"/blog/tags/shell-script"}],readingTime:4.435,hasTruncateMarker:!0,authors:[{name:"Bach Pham",title:"Software Engineer",url:"https://github.com/pxuanbach",imageURL:"https://avatars.githubusercontent.com/u/55500268?v=4",key:"pxuanbach"}],frontMatter:{slug:"zero-downtime-deployment-with-docker-compose-nginx",title:"Zero-downtime Deployments with Docker Compose & Nginx",authors:["pxuanbach"],tags:["automation","deployment","docker","nginx","shell script"],date:"2024-03-24T10:00",image:"/img/01_zero-downtime-deployment-with-docker-compose-nginx/featured.png"},unlisted:!1,prevItem:{title:"Essential modules for developing applications with FastAPI (P1 - Migration)",permalink:"/blog/essential-modules-for-developing-applications-with-fastapi-p1-migration"},nextItem:{title:"Welcome",permalink:"/blog/welcome"}},l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration before applying",id:"configuration-before-applying",level:2},{value:"Docker Compose",id:"docker-compose",level:3},{value:"Nginx",id:"nginx",level:3},{value:"Deployment process",id:"deployment-process",level:3},{value:"New configuration",id:"new-configuration",level:2},{value:"Docker Compose",id:"docker-compose-1",level:3},{value:"Nginx",id:"nginx-1",level:3},{value:"Zero Downtime Deployment",id:"zero-downtime-deployment",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Hey, welcome to my blog!"}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"A few months ago, I worked on a project that utilized Docker and Nginx to deploy the product on Digital Ocean\u2019s VPS. Everything at that time was quite primitive, I had to set up everything from scratch. From containerizing the application to creating a CI/CD pipeline to build, manage, and deploy different Docker image versions."}),"\n",(0,t.jsxs)(n.p,{children:["Docker is a great tool and I love using it in my workflow. I define the Docker services in the configuration file, then pull, up and down the containers to make sure they are up to date. But we have a problem: the time between when I down the container and when I up it. It took\xa0",(0,t.jsx)(n.strong,{children:"2 minutes"}),"\xa0of downtime in total. That\u2019s unacceptable for a product deployed for end-users."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Featured Image",src:o(1034).A+"",width:"703",height:"397"})}),"\n",(0,t.jsx)(n.p,{children:"So I implemented a Zero downtime deployment strategy for that project. The BLUE-GREEN strategy is a basic deployment process, but it\u2019s great when simplicity gets the job done."}),"\n",(0,t.jsx)(n.p,{children:"Now, let\u2019s talk about some stuff."}),"\n",(0,t.jsx)(n.h2,{id:"configuration-before-applying",children:"Configuration before applying"}),"\n",(0,t.jsx)(n.h3,{id:"docker-compose",children:"Docker Compose"}),"\n",(0,t.jsx)(n.p,{children:"I have a configuration file like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'showLineNumbers title="./docker-compose.yml"',children:"services:\n  api:\n    image: pxuanbach/simple-app\n    ports:\n      - '8000:8000'\n    restart: on-failure\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nginx",children:"Nginx"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"nginx.conf"})," configuration will look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",metastring:'{5} showLineNumbers title="./nginx.conf"',children:'server {\n    listen 80 default_server;\n    server_name api.app.com;\n    location / {\n        proxy_pass http://localhost:8000;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $host;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection "upgrade";\n        client_max_body_size 64M;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"deployment-process",children:"Deployment process"}),"\n",(0,t.jsx)(n.p,{children:"It was very easy, and I just followed the steps\u2026"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:"{5} showLineNumbers",children:"docker compose pull\n\ndocker compose down\n\n# ---DOWNTIME HERE---\n\ndocker compose up\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Old Deployment Flow",src:o(2822).A+"",width:"696",height:"141"})}),"\n",(0,t.jsx)(n.p,{children:"Now let's move on to the BLUE-GREEN strategy."}),"\n",(0,t.jsx)(n.h2,{id:"new-configuration",children:"New configuration"}),"\n",(0,t.jsx)(n.h3,{id:"docker-compose-1",children:"Docker Compose"}),"\n",(0,t.jsxs)(n.p,{children:["To apply the BLUE-GREEN strategy, I need to update this configuration file a bit. I use the\xa0",(0,t.jsx)(n.strong,{children:"Anchors and aliases"}),"\xa0features to have a blue and green service with the same configuration. I only change the port number for the green service."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'showLineNumbers title="./docker-compose.yml"',children:"services:\n  api_blue: &api\n    image: pxuanbach/simple-app\n    ports:\n      - '8000:8000'\n    restart: on-failure\n\n  api_green: \n    <<: *api\n    ports:\n      - \"8001:8000\"\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nginx-1",children:"Nginx"}),"\n",(0,t.jsxs)(n.p,{children:["Create a copy of the nginx configuration corresponding to the service name and port. For example\xa0",(0,t.jsx)(n.code,{children:"api_green.conf"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",metastring:'showLineNumbers title="./api_green.conf"',children:"server {\n    listen 80 default_server;\n    server_name api.app.com;\n    location / {\n        proxy_pass http://localhost:8001;\n        ...\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"zero-downtime-deployment",children:"Zero Downtime Deployment"}),"\n",(0,t.jsx)(n.p,{children:"To achieve the goal, I must use the Bash/Shell script. This script will make use of the Docker command line as well as the Nginx. Its goal is to implement the BLUE-GREEN strategy by identifying which service, BLUE or GREEN, is currently active and then standing up the inactive environment in parallel. To avoid downtime, I will update the Nginx configuration before stopping the old container."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:'showLineNumbers title="./pull.run-service.sh"',children:'#!/bin/bash\n\n# Step 1\nBLUE_SERVICE="api_blue"\nBLUE_SERVICE_PORT=8000\nGREEN_SERVICE="api_green"\nGREEN_SERVICE_PORT=8001\n\nTIMEOUT=60  # Timeout in seconds\nSLEEP_INTERVAL=5  # Time to sleep between retries in seconds\nMAX_RETRIES=$((TIMEOUT / SLEEP_INTERVAL))\n\n# Step 2\nif docker ps --format "{{.Names}}" | grep -q "$BLUE_SERVICE"; then\n  ACTIVE_SERVICE=$BLUE_SERVICE\n  INACTIVE_SERVICE=$GREEN_SERVICE\nelif docker ps --format "{{.Names}}" | grep -q "$GREEN_SERVICE"; then\n  ACTIVE_SERVICE=$GREEN_SERVICE\n  INACTIVE_SERVICE=$BLUE_SERVICE\nelse\n  ACTIVE_SERVICE=""\n  INACTIVE_SERVICE=$BLUE_SERVICE\nfi\n\necho "Starting $INACTIVE_SERVICE container"\n\ndocker compose pull $INACTIVE_SERVICE\n\ndocker compose up -d $INACTIVE_SERVICE\n\n# Step 3\n# Wait for the new environment to become healthy\necho "Waiting for $INACTIVE_SERVICE to become healthy..."\nsleep 10\n\ni=0\nwhile [ "$i" -le $MAX_RETRIES ]; do\n  HEALTH_CHECK_URL="http://localhost:8000/health"\n  if [ "$INACTIVE_SERVICE" = "$BLUE_SERVICE" ]; then\n    HEALTH_CHECK_URL="http://localhost:$BLUE_SERVICE_PORT/health"\n  else\n    HEALTH_CHECK_URL="http://localhost:$GREEN_SERVICE_PORT/health"\n  fi\n\n  response=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_CHECK_URL)\n  # Check the HTTP status code\n  if [ $response -eq 200 ]; then\n      echo "$INACTIVE_SERVICE is healthy"\n      break\n  else\n      echo "Health check failed. API returned HTTP status code: $response"\n  fi\n  i=$(( i + 1 ))\n  sleep "$SLEEP_INTERVAL"\ndone\n\n# Step 4\n# update Nginx config\necho "Update Nginx config to $INACTIVE_SERVICE"\ncp ./$INACTIVE_SERVICE.conf /your/config/path/api.conf\n# restart nginx\nnginx -s reload;\n\nsleep 5\n\n# Step 5\n# remove OLD CONTAINER\necho "Remove OLD CONTAINER: $ACTIVE_SERVICE"\ndocker compose rm -fsv $ACTIVE_SERVICE\n\n# remove unused images\n(docker images -q --filter \'dangling=true\' -q | xargs docker rmi) || true\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let\u2019s walk through the script step by step:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"I define the name and port of the blue and green services. And the maximum retry time to check the status of the container. The value depends on your container initialization time."}),"\n",(0,t.jsx)(n.li,{children:"Execute the docker command to find the inactive service and start it."}),"\n",(0,t.jsx)(n.li,{children:"Check the status of the newly initialized container."}),"\n",(0,t.jsxs)(n.li,{children:["Update Nginx configuration and reload it. Using\xa0",(0,t.jsx)(n.code,{children:"nginx -s reload"}),"\xa0to reload Nginx\xa0",(0,t.jsx)(n.strong,{children:"usually does not cause downtime"}),". This is because the command only tells Nginx to reload its configuration, it does not restart the entire process."]}),"\n",(0,t.jsx)(n.li,{children:"Clean up some unused stuff (old docker image, old container)."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In some cases the command\xa0",(0,t.jsx)(n.code,{children:"docker compose rm -fsv"}),"\xa0may not work. Easily change it to:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:"showLineNumbers",children:"docker compose stop $ACTIVE_SERVICE\ndocker compose rm -f $ACTIVE_SERVICE\n"})}),"\n",(0,t.jsx)(n.p,{children:"To deploy the new version, simply run the created script."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:"showLineNumbers",children:"./pull.run-service.sh\n"})}),"\n",(0,t.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"As you can see, we can automate the deployment process with just 1 Bash script. The primary objective is to redirect the proxy to the newest container and then remove the old one."}),"\n",(0,t.jsxs)(n.p,{children:["If you need a project to run a demo on your environment, here are my ",(0,t.jsx)(n.a,{href:"https://github.com/pxuanbach/demo-blue-green-deployment",children:"Git repository"}),"."]}),"\n",(0,t.jsx)(n.h1,{id:"references",children:"References"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.maxcountryman.com/articles/zero-downtime-deployments-with-docker-compose",children:"Zero-Downtime Deployments with Docker Compose \u2013 Max Countryman"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.docker.com/reference/cli/docker/compose/rm/",children:"docker compose rm | Docker Docs"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1034:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/blue-green-deployment-with-nginx-282b1b50b039dd50add056db6bf70e5a.png"},2822:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/images/old-deployment-flow-6e13ae744f8af1e014dee53c9e1c141d.png"},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>a});var t=o(6540);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);